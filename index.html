<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"markovwang.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="马尔可夫妙妙屋">
<meta property="og:url" content="http://markovwang.github.io/index.html">
<meta property="og:site_name" content="马尔可夫妙妙屋">
<meta property="og:locale">
<meta property="article:author" content="Markov Wang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://markovwang.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>马尔可夫妙妙屋</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">马尔可夫妙妙屋</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://markovwang.github.io/2021/08/08/1-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Markov Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="马尔可夫妙妙屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/08/1-3/" class="post-title-link" itemprop="url">1.3 多模板参数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-08-08 23:59:40" itemprop="dateCreated datePublished" datetime="2021-08-08T23:59:40+08:00">2021-08-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-08-09 00:00:55" itemprop="dateModified" datetime="2021-08-09T00:00:55+08:00">2021-08-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-3-多模板参数"><a href="#1-3-多模板参数" class="headerlink" title="1.3 多模板参数"></a>1.3 多模板参数</h2><p>就目前为止, 我们见过的函数模板有两种参数:</p>
<ol>
<li>模板参数,  在函数名前使用尖括号初始化.</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;		<span class="comment">// T是模板参数</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>调用参数, 在函数模板的小括号中声明:</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T a, T b)</span>				<span class="comment">// a和b是调用参数</span></span></span><br></pre></td></tr></table></figure>

<p>只要你想, 拥有多少模板参数都可以, 举个例子, 你可以为<code>max()</code>的调用参数定义两种不同的类型:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function">T1 <span class="title">max</span> <span class="params">(T1 a, T2 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> m - ::<span class="built_in">max</span>(<span class="number">4</span>,<span class="number">7.2</span>);		<span class="comment">// 可以运行, 但是返回类型被定义为了第一个实参的类型.</span></span><br></pre></td></tr></table></figure>

<p> 看起来向<code>max()</code>模板中传不同类型的参数是可行的, 但是, 如同此例中所展示的那样, 这玩意儿有个问题, 如果你把这些类型中的一种类型作为返回类型, 其它实参的类型也将有可能被转换为此类型, 不管这是否符合调用者原本的意图, 因此, (这种写法的)返回类型取决于调用者的调用顺序. 这样的话, 42和66.66的较大值是<code>int</code>的66, 66.66和42的较大值将是<code>double</code>的66.66.</p>
<p>C++提供了多种方法来解决此问题:</p>
<ul>
<li>引入一个第三个类型作为返回类型.</li>
<li>让编译器找到返回类型.</li>
<li>将返回值定义为两者的共同类型.</li>
</ul>
<p>我们接下来将讨论一下.</p>
<h3 id="1-3-1-为返回类型定义模板参数"><a href="#1-3-1-为返回类型定义模板参数" class="headerlink" title="1.3.1 为返回类型定义模板参数"></a>1.3.1 为返回类型定义模板参数</h3><p>我们之前讨论过, 模板实参推断允许我们和调用普通函数的语法一样去调用函数模板: 我们不必显式的根据模板参数定义其类型.</p>
<p>然而, 我们也提到过, 我们可以显式的指定模板的类型:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">max</span> <span class="params">(T a, T b)</span></span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">::max&lt;<span class="keyword">double</span>&gt;(<span class="number">4</span>,<span class="number">7.2</span>);		<span class="comment">// 以double实例化T</span></span><br></pre></td></tr></table></figure>

<p>当模板和调用参数没有联系或者模板参数不能被确定的情况下, 你必须在调用的时候显式的指定模板实参.举个例子, 你可以引入第三个模板实参来决定函数模板的返回类型:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> RT&gt;</span><br><span class="line"><span class="function">RT <span class="title">max</span> <span class="params">(T1 a, T2 b)</span></span>;</span><br></pre></td></tr></table></figure>

<p>然而, 模板实参推导并不会考虑RT, 而且RT也不会出现在函数调用参数的类型中, 因此RT不能被推倒.</p>
<p>结果就是你必须要显式的指定模板实参列表, 举个例子:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> RT&gt;</span></span><br><span class="line"><span class="function">RT <span class="title">max</span> <span class="params">(T1 a, T2 b)</span></span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">::max&lt;<span class="keyword">int</span>,<span class="keyword">double</span>,<span class="keyword">double</span>&gt;(<span class="number">4</span>, <span class="number">7.2</span>);			<span class="comment">//可行, 但是有点脱裤子放屁.</span></span><br></pre></td></tr></table></figure>

<p>目前为止, 我们即看过了丝毫没有提到模板实参的例子, 也看了把所有模板实参均提及的例子. 另外一个方法是只显式的给定第一个实参然后允许推导阶段处理剩余其他的实参. 总之, 你必须指定这些类型到不能隐式判断类型的最后一个. 因此, 如果你改一下模板参数的顺序, 调用者也就仅需要指定返回类型了:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> RT, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function">RT <span class="title">max</span><span class="params">(T1 a, T2 b)</span></span>;</span><br><span class="line">::max&lt;<span class="keyword">double</span>&gt;(<span class="number">4</span>, <span class="number">7.2</span>)			<span class="comment">// 可行, 返回类类型是double, T1,T2为推导出来的.</span></span><br></pre></td></tr></table></figure>

<p>在本例中, 显式将<code>RT</code>设为<code>double</code>的调用<code>max&lt;double&gt;</code>, 但是<code>T1</code>,<code>T2</code>从实参中推断为了<code>int</code>和<code>double</code>. </p>
<p>注意到就算修改过各种不同的<code>max()</code>版本, 也没能得到多少显著的好处. 这个单参数版本中, 你已经可以在传入两个不同类型的实参的时候指定参数. 因此, 让其保持简单并使用单参数版本是个不错的注意.</p>
<p>推导过程的细节详见第15章.</p>
<h3 id="1-3-2-推导返回类型"><a href="#1-3-2-推导返回类型" class="headerlink" title="1.3.2 推导返回类型"></a>1.3.2 推导返回类型</h3><p>如果返回类型取决于模板参数, 最好的, 最简单的方法就是让编译器进行推导. 从C++14起, 我们可以不声明任何返回类型(当然你要写<code>auto</code>关键字啦~):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// basics/maxauto.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">max</span> <span class="params">(T1 a, T2 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上, 使用<code>auto</code>关键字作为返回类型, 而不写尾置返回类型, 表明实际的返回类型必须由函数体中的返回声明语句推导而来. 因此, 代码必须可用且可以匹配多个返回声明.</p>
<p>在C++14之前, 我们只能或多或少是的函数的一部分成为生命的一部分让编译器来判断返回类型,在C++11中, 我们可以从尾置返回类型语法中受益. 即, 我们可以从<code>operator?:</code>操作符返回的类型来声明.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// basics/maxdecltype.hpp</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">max</span><span class="params">(T1 a, T2 b)</span> -&gt; <span class="title">decltype</span><span class="params">(b&lt;a? a:b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	b&lt;a? a:b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处, 结果的类型由<code>?:</code>操作符决定, 这个东西颇为复杂, 但是能产生一个比较直观可预期的结果. (比如当<code>a</code>和<code>b</code>有不同的算术类型的时候, 结果将产生一个两者的公用类型.)</p>
<p>注意到一点:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">max</span> <span class="params">(T1 a, T2 b)</span> -&gt; <span class="title">decltype</span><span class="params">(b&lt;a?a:b)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这是一个声明, 所以编译器用使用<code>?:</code>操作符调用两个参数的规则在编译期来寻找返回类型. 所以函数的实现也不必与其匹配. 实际上, 在此场景下使用<code>true</code>喂给<code>?:</code>操作符的来声明已经足够了.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">max</span> <span class="params">(T1 a, T2 b)</span> -&gt; <span class="title">decltype</span><span class="params">(<span class="literal">true</span>?a:b)</span></span>;</span><br></pre></td></tr></table></figure>

<p>然而, 在某些情况下, 这个定义都有一个很大的问题: 这个可能发生在返回类型是一个引用类型的时候, 因为某些情况下, <code>T</code>可能是个引用, 因此, 你应返回由<code>T</code>退化的类型, 大致如此:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// basics/maxdecltypedecay.hpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, typenam T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">max</span> <span class="params">(T1 a, T2 b)</span> -&gt; <span class="keyword">typename</span> std::decay&lt;<span class="keyword">decltype</span>&lt;<span class="literal">true</span>?a:b&gt;::type</span></span><br><span class="line"><span class="function">&#123;</span></span><br><span class="line">	<span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处, 我们用到了<code>std::decay&lt;&gt;</code>类型萃取, 其使用<code>type</code>来返回结果的类型, 其定义在标准库中的<code>&lt;type_traits&gt;</code>头文件中, (详见附录D.5.) 因为<code>type</code>是一个类型, 所以我们要用<code>typename</code>限定符来获取它. </p>
<p>注意到使用<code>auto</code>来初始化总是会使类型退化, 对于仅仅使用<code>auto</code>作为返回类型时也是如此. <code>auto</code>作为一个返回类型, 其行为如下所示, 其中<code>a</code>被<code>i</code>退化后的类型声明:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span>&amp; ir = i;			<span class="comment">// ir 是 i的引用</span></span><br><span class="line"><span class="keyword">auto</span> a = ir;				<span class="comment">// a被定义为了int类型</span></span><br></pre></td></tr></table></figure>



<h3 id="1-3-3-返回公共类型"><a href="#1-3-3-返回公共类型" class="headerlink" title="1.3.3 返回公共类型"></a>1.3.3 返回公共类型</h3><p>从C++11起, C++标准库提供了一种能够选择更通用的类型, <code>std::common_type&lt;&gt;::type</code>返回两者或者更多不同类型的参数的共同类型. 举个例子:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// basics/maxcommon.hpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &lt;type_traits.</span></span><br><span class="line"><span class="function">std::<span class="keyword">common_type_t</span>&lt;T1,T2&gt; <span class="title">max</span> <span class="params">(T1 a, T2 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重复一次, <code>std::common_type&lt;&gt;</code>是一个类型萃取, 其定义在<code>&lt;type_traits&gt;</code>中, 其有一个带有<code>type</code>成员的结构体, 作为结果类型. 因此, 其核心用途如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> std::common_type&lt;T1,T2&gt;::type <span class="comment">// C++11 起</span></span><br></pre></td></tr></table></figure>

<p>不过, 从C++14起, 你可以通过在这些萃取的后面加个<code>_t</code>来简化其用法. 以省略<code>typename</code>和<code>::type</code>(详见2.8节), 所以可以如此简单的定义返回类型:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="keyword">common_type_t</span>&lt;T1,T2&gt;</span><br></pre></td></tr></table></figure>

<p><code>std::commom_type</code>的实现用了些模板编程的技巧, 将在26.5.2小节讨论. 在内部, 使用<code>?:</code>操作符确定返回类型或者是为某些特殊的类型特化. 因此, 不管怎样的调用顺序均可以返回类型<code>double</code>. 注意<code>std::common_type</code>也会退化, 详见附录D.5.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://markovwang.github.io/2021/08/08/1-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Markov Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="马尔可夫妙妙屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/08/1-2/" class="post-title-link" itemprop="url">1.2 模板实参推断</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-08-08 23:57:27 / Modified: 23:59:33" itemprop="dateCreated datePublished" datetime="2021-08-08T23:57:27+08:00">2021-08-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-2-模板实参推断"><a href="#1-2-模板实参推断" class="headerlink" title="1.2 模板实参推断"></a>1.2 模板实参推断</h2><p>当我们用实参调用一个类似<code>max()</code>的函数模板的时候, 模板形参将取决于我们传入的实参. 如果我们把两个<code>int</code>创个<code>T</code>, C++的编译器必将认为T是<code>int</code>.</p>
<p>然而, <code>T</code>有可能只是类型的一部分, 举个例子, 当我们使用常量引用声明<code>max()</code>的时候:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">max</span> <span class="params">(T <span class="keyword">const</span>&amp; a, T <span class="keyword">const</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候向其中穿入一个<code>int</code>, 此时<code>T</code>将被推导为<code>int</code>, 因为函数形参匹配<code>int const&amp; </code>的形式.</p>
<h3 id="类型推断期间的类型转换"><a href="#类型推断期间的类型转换" class="headerlink" title="类型推断期间的类型转换"></a>类型推断期间的类型转换</h3><p>注意到在类型推断期间自动类型转换是十分有限的:</p>
<ul>
<li>当以引用形式声明调用参数时, 多么简单的类型转换也不会应用在类型推导中, 两个由相同的模板实参<code>T</code>声明的实参必须精确的相同.</li>
<li>当以值的形式声明调用参数时, 只会发生类型退化这种简单转换: <code>const</code>和<code>volatile</code>限定符会被忽略, 引用会被转化为引用类型, 原生数组和函数将被转化为相应的指针类型, 对于被相同模板形参<code>T</code>声明的两个实参退化后的类型必须匹配.</li>
</ul>
<p>举个例子:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T a, T b)</span></span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> c = <span class="number">42</span>;</span><br><span class="line"><span class="built_in">max</span>(i, c);				<span class="comment">// T将被推导为int类型;</span></span><br><span class="line"><span class="built_in">max</span>(c, c);				<span class="comment">// T将被推导为int类型;</span></span><br><span class="line"><span class="keyword">int</span>&amp; ir = i;</span><br><span class="line"><span class="built_in">max</span>(i, ir);				<span class="comment">// T将被推导为int类型;</span></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">4</span>];</span><br><span class="line"><span class="built_in">foo</span>(&amp;i, arr);			<span class="comment">// T将被推导为int*类型;</span></span><br></pre></td></tr></table></figure>

<p>然而下面这些会导致错误:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">max</span>(<span class="number">4</span>, <span class="number">7.2</span>);			<span class="comment">// 错误, T既可以被推导为int, 也可以被推导为double</span></span><br><span class="line">std::string s;</span><br><span class="line"><span class="built_in">foo</span>(<span class="string">&quot;hello&quot;</span>, s);		<span class="comment">// 错误, T既可以被推导为 char const[6], 也可以被推导为std::string</span></span><br></pre></td></tr></table></figure>

<p>当然, 我们倒是有解决这些问题的方法:</p>
<ol>
<li>对实参进行类型转化, 时期都能匹配:</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">max</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(<span class="number">4</span>), <span class="number">7.2</span>);		<span class="comment">// 可行</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>指定T的类型, 阻止编译器尝试进行类型推导:</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max&lt;<span class="keyword">double</span>&gt;(<span class="number">4</span>, <span class="number">7.2</span>);		<span class="comment">// 可行</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>指定可能有不同类型的参数</li>
</ol>
<p>1.3节汇兑这种情况进行详细说明, 7.2节和15章将详细讨论类型推导中的类型转换.</p>
<h3 id="默认实参类型推导"><a href="#默认实参类型推导" class="headerlink" title="默认实参类型推导"></a>默认实参类型推导</h3><p>注意到, 在默认调用实参的时候, 类型推导不会起作用, 举个例子:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T = <span class="string">&quot;&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(<span class="number">1</span>);					<span class="comment">// 可行, 将T推导为int, 即调用f&lt;int&gt;(1);</span></span><br><span class="line"><span class="built_in">f</span>();					<span class="comment">// 不行, 无法推导T的类型;</span></span><br></pre></td></tr></table></figure>

<p>为了支撑这个例子, 你需要为此模版形参生命一个默认实参, 其将在1.4小姐讨论.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T = std::string&gt;</span><br><span class="line">void f(T = &quot;&quot;);</span><br><span class="line">// ...</span><br><span class="line">f();					// 可行</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://markovwang.github.io/2021/08/06/My-First-Blog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Markov Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="马尔可夫妙妙屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/06/My-First-Blog/" class="post-title-link" itemprop="url">1.1 初见函数模板</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-08-06 17:39:05" itemprop="dateCreated datePublished" datetime="2021-08-06T17:39:05+08:00">2021-08-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-08-08 23:57:04" itemprop="dateModified" datetime="2021-08-08T23:57:04+08:00">2021-08-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第一章-函数模板"><a href="#第一章-函数模板" class="headerlink" title="第一章: 函数模板"></a>第一章: 函数模板</h1><p>本章介绍函数模板, 函数模板是一种参数化的函数们, 他们能够提供一个函数族.</p>
<h2 id="1-1-初遇函数模板"><a href="#1-1-初遇函数模板" class="headerlink" title="1.1 初遇函数模板"></a>1.1 初遇函数模板</h2><p>函数模板提供一种对不同的类型可以被调用的函数行为. 换言之, 函数模板提供一个函数族, 这种表示方法看起来像普通的函数——除了它的一些元素未被定义, 这些元素被参数化了. 为了能够给你展示, 我们来看一个简单的例子.</p>
<h3 id="1-1-1-定义模板"><a href="#1-1-1-定义模板" class="headerlink" title="1.1.1 定义模板"></a>1.1.1 定义模板</h3><p>下面是个能够返回两个值的中较大值的一个函数模板:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义在头文件 basics/max1.hpp中</span></span><br><span class="line"></span><br><span class="line"><span class="function">T <span class="title">max</span> <span class="params">(T a,T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 若 b &lt; a 则返回a, 否则返回 b</span></span><br><span class="line">	<span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个模板定义了一个函数族, 能够返回两只中的较大值, 这两个值由函数参数<code>a</code>和<code>b</code>传入[^1]. 这些参数的类型保留为<em>模板参数<code>T</code></em>, 如同刚刚看到的这个例子, 模板参数需要以以下的方式进行声明:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; 逗号分隔的参数列表 &gt;</span><br></pre></td></tr></table></figure>

<p>在本例中, 参数列表是<code>typename T</code>. 注意<code>&lt;</code>和<code>&gt;</code>符号被用作了括号, 我们称其为<em>尖括号</em>,  <code>typename</code>关键字引入了一个类型参数, 这是C++程序中大多模板参数的样子, 但是其他样子的参数也有, 对此我们在第三章见.</p>
<p>此处, 类型参数是<code>T</code>, 你可以把任何标识符用作参数的名字, 但是用<code>T</code>比较方便. 这个类型参数表示它可以是任意类型, 直到调用者调用此函数才会决定其类型. 你能使用任何类型(基本类型, 类, 或者其他什么)——只要它能提供模板使用的操作. 在本例中, 类型<code>T</code>必须支持<code>&lt;操作符</code>因为<code>a</code>和<code>b</code>将使用此操作符进行比较, 可能<code>max()</code>的定义中不太容易看出的是类型T必须是可复制的, 以便能够返回.[^2]</p>
<p>因为一些历史因素, 你也能用<code>class</code>关键字代替<code>typename</code>关键字定义类型参数, <code>typename</code>关键字在C++98被提出来. 在那之前, <code>class</code>关键字是唯一被用来引入类型参数的, 直到今天其依然是合法的.在语义上两者也是没有区别的. 然而, 这样写可能导致一些字面上误会, 所以还是用<code>typename</code>比较好. 然而, 虽然<code>class</code>是可以用的, 但<code>struct</code>是不可以用在类型参数的声明的.</p>
<h3 id="1-1-2-使用模板"><a href="#1-1-2-使用模板" class="headerlink" title="1.1.2 使用模板"></a>1.1.2 使用模板</h3><p>下面的程序展示了如何使用<code>max()</code>函数模板:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// basics/max1.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;max1.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;max(7,i): &quot;</span> &lt;&lt; ::<span class="built_in">max</span>(<span class="number">7</span>,i) &lt;&lt; ’\n’;</span><br><span class="line">	<span class="keyword">double</span> f1 = <span class="number">3.4</span>; <span class="keyword">double</span> f2 = <span class="number">-6.7</span>;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;max(f1,f2): &quot;</span> &lt;&lt; ::<span class="built_in">max</span>(f1,f2) &lt;&lt; ’\n’;</span><br><span class="line">	std::string s1 = <span class="string">&quot;mathematics&quot;</span>; std::string s2 = <span class="string">&quot;math&quot;</span>;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;max(s1,s2): &quot;</span> &lt;&lt; ::<span class="built_in">max</span>(s1,s2) &lt;&lt; ’\n’;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在本程序中, <code>max</code>被调用了三次, 第一次是两个<code>int</code>, 第二次是两个<code>double</code>, 第三次是<code>std::string</code>, 每次均计算了较大值. 程序的输出结果如下所示:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">max(7,i): 42</span><br><span class="line">max(f1,f2): 3.4</span><br><span class="line">max(s1,s2): mathematics</span><br></pre></td></tr></table></figure>

<p>注意到每次调用的时候均写了<code>::</code>, 这是为了确保其能够在全局命名空间中找到. 毕竟我们的标准库还有一个<code>std::max()</code>, 在某些情况下调用会导致二义性[^3].</p>
<p>模板并非被编译为一个能够处理任何类型的函数实体, 相反, 针对不同类型的调用, 模板会被编译成不同的函数实体.[^4] 因此, <code>max()</code>针对这三个类型均被编译了一次, 比如, 刚刚, 我们第一次调用<code>max()</code>的时候, 函数模板中的<code>T</code>被替换成了<code>int</code>, 也就是这样了:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个替换模板参数为具体类型的过程被称为<em>模板实例化</em>, 它能得到模板的一个实例[^5].</p>
<p>注意, 仅仅是使用模板就会触发模板实例化的过程, 所以不用程序员去单独手动请求实例化. </p>
<p>类似的, 使用其它类型调用<code>max()</code>模板是都会被各自实例化的.</p>
<p>注意一点: <code>void</code>类型是一个合法的模板类型实参, 举个例子:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">foo</span><span class="params">(T*)</span></span></span><br><span class="line"><span class="function"></span>&#123; &#125;</span><br><span class="line"><span class="keyword">void</span>* vp = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="built_in">foo</span>(vp); <span class="comment">// OK: 推断为void</span></span><br><span class="line"><span class="built_in">foo</span>(<span class="keyword">void</span>*)</span><br></pre></td></tr></table></figure>



<h3 id="1-1-3-模板两轮翻译-原文为’Two-Phase-Translation‘"><a href="#1-1-3-模板两轮翻译-原文为’Two-Phase-Translation‘" class="headerlink" title="1.1.3 模板两轮翻译(原文为’Two-Phase Translation‘)"></a>1.1.3 模板两轮翻译(原文为’<em>Two-Phase Translation</em>‘)</h3><p><em>这个国内似乎没有固定的翻译, 有的说替换 ,有的说翻译, 差别不大</em></p>
<p>尝试把模板实例化一个不支持其中用到的所有操作的实例会导致编译期报错, 举个例子:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::complex&lt;<span class="keyword">float</span>&gt; c1, c2; <span class="comment">// 并没有提供 &lt;操作符</span></span><br><span class="line">…</span><br><span class="line">::<span class="built_in">max</span>(c1,c2); <span class="comment">// 编译期报错终止</span></span><br></pre></td></tr></table></figure>

<p>因此, 模板是经过两轮”编译’’的:</p>
<ol>
<li>在定义的时候没有实例化, 模板代码会忽略掉和模板参数相关的代码并进行检查, 其包括:<ul>
<li>检查发现语法, 比如丢了分号.</li>
<li>出现了未知的名字: 类型名, 函数名——与模板参数无关的.</li>
<li>于模板参数无关的静态断言将被检查.</li>
</ul>
</li>
<li>在实例化期间, 模板会再被检查一次, 以保障代码是合法的, 换言之, 所有依赖模板参数的代码会被二次检查,举个例子:</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">undeclared</span>(); <span class="comment">// 如果unceclared()未被定义, 将在第一轮报编译期报错</span></span><br><span class="line">	<span class="built_in">undeclared</span>(t); <span class="comment">// 如果unceclared(T)未被定义, 将在第二轮报编译期报错</span></span><br><span class="line">	<span class="built_in"><span class="keyword">static_assert</span></span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) &gt; <span class="number">10</span>, <span class="comment">//如果 sizeof(int)&lt;=10 总是会报错</span></span><br><span class="line">								<span class="string">&quot;int too small&quot;</span>);</span><br><span class="line">	<span class="built_in"><span class="keyword">static_assert</span></span>(<span class="built_in"><span class="keyword">sizeof</span></span>(T) &gt; <span class="number">10</span>, <span class="comment">//如果T的大小小于10则在第二轮报错.</span></span><br><span class="line">								<span class="string">&quot;T too small&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>名字将被检查两次这件事被称为<code>两轮检查</code>, 将在14.3.1小结讨论.</p>
<p>不过注意到一些编译器不能在第一轮实例化时进行应完成的全部检查[^6], 所以你只能在实例化时才发现应在第一步就被检查出的问题.</p>
<h3 id="编译与链接"><a href="#编译与链接" class="headerlink" title="编译与链接"></a>编译与链接</h3><p>两轮检查将会导致在使用中出现很严重的问题: 当一个函数模板以一种触发其实例化的方式使用的时候, 编译器会(在某些情况下)查看模板的定义, 其将打破对于常规函数编译和链接的区别, 处理此问题的方法将在第九章介绍, 目前, 我们只讲最简单的方法, 在头文件中定义每一个模板.</p>
<p>[^1]: 注意到<code>max()</code>返回的是”<code>b &lt; a ? a : b</code>“, 而非”<code>a &lt; b ? b: a</code>“, 以保证函数能够处理两个值等价却不相等的问题, <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/operator_comparison">https://zh.cppreference.com/w/cpp/language/operator_comparison</a><br>[^2]: 在C++17之前, 类型<code>T</code>要求可拷贝以传入实参, 但从C++17起, 你可以传入一个临时值(右值),尽管其不能提供一拷贝或者移动构造函数.<br>[^3]: 比如, 如果如果一个实参类型在<code>std</code>空间中定义了, 根据C++的查找规则, 全局和<code>std</code>命名空间中的同名函数均会被找到.<br>[^4]: 一个实体, 谁都能调, 这种是可以做到的, 但不会在实际编程中用到.(它在运行时的效率会低很多)所有的语言规则均是基于不同实参,不同实体的原则.<br>[^5]: <code>实例</code>和<code>实例化</code>这两个术语对于面向对象语言,在上下文不同时有不同含义: 从名字上来看, 是一个类的实体的含义. 然而. 这本书是讲模板的, 这个词主要针对模板, 除非我们做了特殊说明.<br>[^6]: 举个例子, MSVC编译器的某些版本允许不依赖模板参数的未定义名称, 甚至还允许一些语法错误,比如少了个分号.(又黑我大微软, 请加大力度)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://markovwang.github.io/2021/08/06/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Markov Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="马尔可夫妙妙屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/06/hello-world/" class="post-title-link" itemprop="url">初次见面...</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-08-06 17:33:35" itemprop="dateCreated datePublished" datetime="2021-08-06T17:33:35+08:00">2021-08-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-08-08 23:49:56" itemprop="dateModified" datetime="2021-08-08T23:49:56+08:00">2021-08-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>This is Markov Wang. Studying algorithms of  decoding neural signal at Beijing Chuilei University(北京垂雷大学).</p>
<p>Also study C++ and Rust(as a beginer).</p>
<p>Interested in computer gragphics, signal processing, building high-performance software.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Markov Wang"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Markov Wang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Markov Wang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
